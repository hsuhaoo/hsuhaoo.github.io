(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{500:function(e,t,s){"use strict";s.r(t);var v=s(4),n=Object(v.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("strong",[e._v("git init")])]),e._v(" "),s("p",[s("code",[e._v("git init")]),e._v("命令只做一件事，就是在项目根目录下创建一个"),s("code",[e._v(".git")]),e._v("子目录，用来保存版本信息。")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" .git\nbranches/\nconfig\ndescription\nHEAD\nhooks/\ninfo/\nobjects/\nrefs/\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[s("strong",[e._v("git add")])]),e._v(" "),s("p",[s("code",[e._v("git add test.txt")]),e._v(" 做了两步操作。每一步操作实际上都有对应的git命令，这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。")]),e._v(" "),s("p",[e._v("一是保存对象，将"),s("code",[e._v("test.txt")]),e._v("的当前内容压缩成二进制文件，存入 Git。压缩后的二进制文件，称为一个 blob对象，保存在"),s("code",[e._v(".git/objects")]),e._v("目录。还会计算当前内容的 SHA1 哈希值（长度40的字符串），作为该对象的文件名。")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("ls")]),e._v(" -R .git/objects\n\n.git/objects/e6:\n9de29bb2d1d6434b8b29ae775ad8c2e48c5391\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("上面代码可以看到，"),s("code",[e._v(".git/objects")]),e._v("下面多了一个子目录，目录名是哈希值的前2个字符，该子目录下面有一个文件，文件名是哈希值的后38个字符。")]),e._v(" "),s("p",[e._v('二是对变动的文件进行记录。所有变动的文件，Git 都记录在一个区域，叫做"暂存区"（英文叫做 index 或者 stage），位于'),s("code",[e._v(".git/index")]),e._v(" 文件。")]),e._v(" "),s("p",[s("strong",[e._v("git commit")])]),e._v(" "),s("p",[e._v("commit将暂存区的信息写入历史，这就相当于生成了当前项目的一个快照（snapshot）。")]),e._v(" "),s("p",[e._v("项目的历史就是由不同时点的快照构成。Git 可以将项目恢复到任意一个快照。")]),e._v(" "),s("p",[e._v('前面保存对象的时候，只是保存单个文件，并没有记录文件之间的目录关系（哪个文件在哪里）。git commit -m "first commit"包含两个步骤：')]),e._v(" "),s("p",[e._v("一是将目录结构作为二进制对象（树对象）保存，也保存在"),s("code",[e._v(".git/objects")]),e._v("目录里面，对象名就是哈希值。")]),e._v(" "),s("p",[e._v("二是将这个目录结构与一些元数据（包括提交说明和作者等）一起生成一个 committer对象。")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("git")]),e._v(" cat-file -p c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa\n\ntree c3b8bb102afeca86037d5b5dd89ceeb0090eae9d\nauthor ruanyf  "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1538889134")]),e._v(" +0800\ncommitter ruanyf  "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1538889134")]),e._v(" +0800\n\nfirst commit\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("上面代码中，输出结果的第一行是本次快照对应的目录树对象（tree），第二行和第三行是作者和提交人信息，最后是提交说明。")]),e._v(" "),s("p",[e._v("从这里可以看到，git并不保存数据的差异，而是直接记录每个完整的数据文件。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。")]),e._v(" "),s("p",[s("strong",[e._v("git branch")])]),e._v(" "),s("p",[e._v("所谓分支（branch）就是指向某个快照的指针，分支名就是指针名。哈希值是无法记忆的，分支使得用户可以为快照起别名。而且，分支会自动更新，如果当前分支有新的快照，指针就会自动指向它。比如，master 分支就是有一个叫做 master 指针，它指向的快照就是 master 分支的当前快照。")]),e._v(" "),s("p",[e._v("Git 有一个特殊指针"),s("code",[e._v("HEAD")]),e._v("， 总是指向当前分支的最近一次快照。另外，Git 还提供简写方式，"),s("code",[e._v("HEAD^")]),e._v("指向 "),s("code",[e._v("HEAD")]),e._v("的前一个快照（父节点），"),s("code",[e._v("HEAD~6")]),e._v("则是"),s("code",[e._v("HEAD")]),e._v("之前的第6个快照。")]),e._v(" "),s("p",[e._v("每一个分支指针都是一个文本文件，保存在"),s("code",[e._v(".git/refs/heads/")]),e._v("目录，该文件的内容就是它所指向的快照的二进制对象名（哈希值）。")]),e._v(" "),s("p",[e._v("下面三个命令会自动改写分支指针。")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("git commit")]),e._v("：当前分支指针移向新创建的快照。")]),e._v(" "),s("li",[s("code",[e._v("git pull")]),e._v("：当前分支与远程分支合并后，指针指向新创建的快照。")]),e._v(" "),s("li",[s("code",[e._v("git reset [commit_sha]")]),e._v("：当前分支指针重置为指定快照。")]),e._v(" "),s("li",[s("code",[e._v("git checkout")]),e._v("命令用于切换到某个快照。")])]),e._v(" "),s("p",[s("strong",[e._v("git reset")])]),e._v(" "),s("p",[s("code",[e._v("reset")]),e._v(" 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（"),s("code",[e._v("checkout")]),e._v(" 所做的）；"),s("code",[e._v("reset")]),e._v(" 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 "),s("code",[e._v("master")]),e._v(" 分支， 运行 "),s("code",[e._v("git reset 9e5e6a4")]),e._v(" 将会使 "),s("code",[e._v("master")]),e._v(" 指向 "),s("code",[e._v("9e5e6a4")]),e._v("。")]),e._v(" "),s("p",[e._v("无论你调用了何种形式的带有一个提交的 "),s("code",[e._v("reset")]),e._v("，它首先都会尝试这样做。 使用 "),s("code",[e._v("reset --soft")]),e._v("，它将仅仅停在那儿。")]),e._v(" "),s("p",[e._v("接下来，"),s("code",[e._v("reset")]),e._v(" 会用 HEAD 指向的当前快照的内容来更新索引。如果指定 "),s("code",[e._v("--mixed")]),e._v(" 选项，"),s("code",[e._v("reset")]),e._v(" 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项。")]),e._v(" "),s("p",[s("code",[e._v("reset")]),e._v(" 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 "),s("code",[e._v("--hard")]),e._v(" 选项，它将会继续这一步。必须注意，"),s("code",[e._v("--hard")]),e._v(" 标记是 "),s("code",[e._v("reset")]),e._v(" 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 "),s("code",[e._v("reset")]),e._v(" 调用都可以轻松撤消，但是 "),s("code",[e._v("--hard")]),e._v(" 选项不能，因为它强制覆盖了工作目录中的文件。 当文件被提交后，我们可以通过 "),s("code",[e._v("reflog")]),e._v(" 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。注意，reflog信息没法与其他任何人共享，每个人都是自己特有的reflog。重要的一点是，它不是永久保存的，有一个可配置的过期时间，reflog中过期的信息会被自动删除。")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E4%B8%8E%E4%B8%8A%E5%B1%82%E5%91%BD%E4%BB%A4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Git 内部原理 - 底层命令与上层命令"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset",target:"_blank",rel:"noopener noreferrer"}},[e._v("Git 工具 - 重置揭密"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2018/10/git-internals.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Git 原理入门 - 阮一峰的网络日志"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);