(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{499:function(a,t,v){"use strict";v.r(t);var r=v(4),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"浏览器缓存-http缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存-http缓存"}},[a._v("#")]),a._v(" 浏览器缓存(http缓存)")]),a._v(" "),v("p",[a._v("浏览器缓存是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为。")]),a._v(" "),v("p",[a._v("浏览器缓存包括")]),a._v(" "),v("p",[a._v("memory cache")]),a._v(" "),v("p",[a._v("disk cache")]),a._v(" "),v("p",[a._v("Push Cache （HTTP/2 中的内容）。")]),a._v(" "),v("h4",{attrs:{id:"缓存原理-访问缓存优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存原理-访问缓存优先级"}},[a._v("#")]),a._v(" 缓存原理 (访问缓存优先级)")]),a._v(" "),v("ol",[v("li",[a._v("先在内存中查找,如果有,直接加载。")]),a._v(" "),v("li",[a._v("如果内存中不存在,则在硬盘中查找,如果有直接加载。")]),a._v(" "),v("li",[a._v("如果硬盘中也没有,那么就进行网络请求。")]),a._v(" "),v("li",[a._v("请求获取的资源缓存到硬盘和内存。")])]),a._v(" "),v("h3",{attrs:{id:"浏览器缓存的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的分类"}},[a._v("#")]),a._v(" 浏览器缓存的分类")]),a._v(" "),v("ol",[v("li",[a._v("强缓存")]),a._v(" "),v("li",[a._v("协商缓存")])]),a._v(" "),v("p",[a._v("浏览器再向服务器请求资源时,首先判断是否命中强缓存,再判断是否命中协商缓存!")]),a._v(" "),v("h3",{attrs:{id:"浏览器缓存的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的优点"}},[a._v("#")]),a._v(" 浏览器缓存的优点")]),a._v(" "),v("p",[a._v("1.减少了冗余的数据传输")]),a._v(" "),v("p",[a._v("2.减少了服务器的负担，大大提升了网站的性能")]),a._v(" "),v("p",[a._v("3.加快了客户端加载网页的速度")]),a._v(" "),v("h3",{attrs:{id:"强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),v("p",[a._v("浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。")]),a._v(" "),v("p",[a._v("这里的 header 中的信息指的是 expires 和 cahe-control.")]),a._v(" "),v("h4",{attrs:{id:"expires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),v("p",[a._v("该字段是 "),v("strong",[a._v("http1.0")]),a._v(" 时的规范，它的值为一个"),v("strong",[a._v("绝对时间")]),a._v("的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。")]),a._v(" "),v("h4",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),v("p",[a._v("Cache-Control 是 "),v("strong",[a._v("http1.1")]),a._v(" 时出现的 header 信息，主要是利用该字段的 "),v("strong",[a._v("max-age")]),a._v(" 值来进行判断，它是一个"),v("strong",[a._v("相对时间")]),a._v("，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：")]),a._v(" "),v("p",[v("strong",[a._v("no-cache")]),a._v("：需要进行协商缓存，发送请求到服务器确认是否使用缓存。")]),a._v(" "),v("p",[v("strong",[a._v("no-store")]),a._v("：禁止使用缓存，每一次都要重新请求数据。")]),a._v(" "),v("p",[v("strong",[a._v("public")]),a._v("：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。")]),a._v(" "),v("p",[v("strong",[a._v("private")]),a._v("：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。")]),a._v(" "),v("p",[v("strong",[a._v("Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。")])]),a._v(" "),v("h3",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),v("p",[a._v("当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。")]),a._v(" "),v("p",[a._v("这里的 header 中的信息指的是 Last-Modify/If-Modify-Since 和 ETag/If-None-Match.")]),a._v(" "),v("h4",{attrs:{id:"last-modify-if-modify-since"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#last-modify-if-modify-since"}},[a._v("#")]),a._v(" Last-Modify/If-Modify-Since")]),a._v(" "),v("p",[a._v("浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。")]),a._v(" "),v("p",[a._v("当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。")]),a._v(" "),v("p",[a._v("如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。")]),a._v(" "),v("p",[a._v("缺点:")]),a._v(" "),v("p",[a._v("短时间内资源发生了改变，Last-Modified 并不会发生变化。")]),a._v(" "),v("p",[a._v("周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag。")]),a._v(" "),v("h4",{attrs:{id:"etag-if-none-match"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[a._v("#")]),a._v(" ETag/If-None-Match")]),a._v(" "),v("p",[a._v("与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。")]),a._v(" "),v("h3",{attrs:{id:"service-worker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),v("p",[a._v("Service Worker 是运行在浏览器背后的"),v("strong",[a._v("独立线程")]),a._v("，一般可以用来实现缓存功能，可以让开发者自己控制管理缓存的内容以及版本。使用 Service Worker的话，传输协议必须为 "),v("strong",[a._v("HTTPS")]),a._v("。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们"),v("strong",[a._v("自由控制")]),a._v("缓存哪些文件、如何匹配缓存、如何读取缓存，并且"),v("strong",[a._v("缓存是持续性的")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),v("p",[a._v("当浏览器再次访问一个已经访问过的资源时，它会这样做：")]),a._v(" "),v("p",[a._v("1.看看是否命中强缓存，如果命中，就直接使用缓存了。")]),a._v(" "),v("p",[a._v("2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。")]),a._v(" "),v("p",[a._v("3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。")]),a._v(" "),v("p",[a._v("4.否则，返回最新的资源。")]),a._v(" "),v("h2",{attrs:{id:"cdn-缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存"}},[a._v("#")]),a._v(" CDN 缓存")]),a._v(" "),v("h3",{attrs:{id:"什么是cdn"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是cdn"}},[a._v("#")]),a._v(" 什么是CDN")]),a._v(" "),v("p",[a._v("全称 Content Delivery Network,即内容分发网络。")]),a._v(" "),v("p",[a._v("用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。")]),a._v(" "),v("h3",{attrs:{id:"cdn缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn缓存"}},[a._v("#")]),a._v(" CDN缓存")]),a._v(" "),v("p",[a._v("关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Cache-control: max-age\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("p",[a._v("的字段来设置CDN边缘节点数据缓存时间。")]),a._v(" "),v("p",[a._v("当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。")]),a._v(" "),v("h3",{attrs:{id:"cdn-优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn-优势"}},[a._v("#")]),a._v(" CDN 优势")]),a._v(" "),v("ol",[v("li",[a._v("CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。")]),a._v(" "),v("li",[a._v("大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。")])]),a._v(" "),v("h2",{attrs:{id:"dns-缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-缓存"}},[a._v("#")]),a._v(" DNS 缓存")]),a._v(" "),v("h3",{attrs:{id:"什么是dns"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是dns"}},[a._v("#")]),a._v(" 什么是DNS")]),a._v(" "),v("p",[a._v("全称 Domain Name System ,即域名系统。")]),a._v(" "),v("blockquote",[v("p",[a._v("万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。")])]),a._v(" "),v("h3",{attrs:{id:"dns解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[a._v("#")]),a._v(" DNS解析")]),a._v(" "),v("p",[a._v("简单的说,通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("www.dnscache.com (域名) - DNS解析 -> 11.222.33.444 (IP地址)\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("h3",{attrs:{id:"dns缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns缓存"}},[a._v("#")]),a._v(" DNS缓存")]),a._v(" "),v("p",[a._v("有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。")]),a._v(" "),v("p",[a._v("DNS查询过程如下:")]),a._v(" "),v("ol",[v("li",[a._v("首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。")]),a._v(" "),v("li",[a._v("如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。")]),a._v(" "),v("li",[a._v("如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。")]),a._v(" "),v("li",[a._v("如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。（例：本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。）")])]),a._v(" "),v("h3",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000017962411",target:"_blank",rel:"noopener noreferrer"}},[a._v("实践这一次，彻底搞懂浏览器缓存机制"),v("OutboundLink")],1)]),a._v(" "),v("p",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/115243059",target:"_blank",rel:"noopener noreferrer"}},[a._v("service worker 是什么？看这篇就够了"),v("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=e.exports}}]);