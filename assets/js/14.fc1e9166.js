(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{496:function(_,v,e){"use strict";e.r(v);var t=e(4),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"重排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[_._v("#")]),_._v(" 重排")]),_._v(" "),e("p",[_._v("呈现器在创建完成并添加到呈现树时，这个时候并没有包含位置和大小信息。计算这些值的过程称为布局或重排。")]),_._v(" "),e("p",[_._v("HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历。")]),_._v(" "),e("p",[_._v("坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。")]),_._v(" "),e("p",[_._v("布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 ")]),e("html",[_._v(" 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。"),e("p"),_._v(" "),e("p",[_._v("根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。")]),_._v(" "),e("p",[_._v("所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。")]),_._v(" "),e("p",[_._v("前面提到了，每当一个Render节点加入Render树时，它不包含位置和尺寸，计算元素的位置和尺寸的过程称为Layout。")]),_._v(" "),e("p",[_._v("Browser使用流模型的Layout算法。所谓流模型，即是指Layout的过程只需进行一遍即可完成，后出现在流中的元素不会影响前出现在流中的元素，Layout过程只需从左至右从上至下一遍完成即可。但实际实现中，流模型会有例外。")]),_._v(" "),e("p",[_._v("Layout是一个递归的过程，每个节点都负责自己及其子节点的Layout。Layout结果是相对父节点的坐标和尺寸。其过程可以简述为：")]),_._v(" "),e("ul",[e("li",[_._v("父节点确定自己的宽度")]),_._v(" "),e("li",[_._v("父节点完成子节点放置，确定其相对坐标")]),_._v(" "),e("li",[_._v("节点确定自己的宽度和高度")]),_._v(" "),e("li",[_._v("父节点根据所有的子节点高度计算自己的高度")])]),_._v(" "),e("p",[_._v("为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统（Dirty bit system）。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。")]),_._v(" "),e("p",[_._v("有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局（Layout）。")]),_._v(" "),e("h4",{attrs:{id:"全局布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局布局"}},[_._v("#")]),_._v(" 全局布局")]),_._v(" "),e("p",[_._v("全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：")]),_._v(" "),e("ol",[e("li",[_._v("影响所有呈现器的全局样式更改，例如字体大小更改。")]),_._v(" "),e("li",[_._v("屏幕大小调整。")])]),_._v(" "),e("h4",{attrs:{id:"增量布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增量布局"}},[_._v("#")]),_._v(" 增量布局")]),_._v(" "),e("p",[_._v("布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。")]),_._v(" "),e("p",[_._v("当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。")]),_._v(" "),e("h4",{attrs:{id:"异步布局和同步布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步布局和同步布局"}},[_._v("#")]),_._v(" 异步布局和同步布局")]),_._v(" "),e("p",[_._v("增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。Webkit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。")]),_._v(" "),e("p",[_._v("全局布局往往是同步触发的。")]),_._v(" "),e("p",[_._v("有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。")]),_._v(" "),e("h2",{attrs:{id:"重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[_._v("#")]),_._v(" 重绘")]),_._v(" "),e("p",[_._v("如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。")]),_._v(" "),e("p",[_._v("在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。")]),_._v(" "),e("p",[_._v("在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。")]),_._v(" "),e("p",[_._v("绘制工作是使用用户界面基础组件完成的。")]),_._v(" "),e("h4",{attrs:{id:"全局绘制和增量绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局绘制和增量绘制"}},[_._v("#")]),_._v(" 全局绘制和增量绘制")]),_._v(" "),e("p",[_._v("和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。")]),_._v(" "),e("p",[_._v("在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。")]),_._v(" "),e("p",[_._v("在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。")]),_._v(" "),e("h4",{attrs:{id:"绘制顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制顺序"}},[_._v("#")]),_._v(" 绘制顺序")]),_._v(" "),e("p",[_._v("在谈绘制顺序之前，先谈谈堆栈样式上下文。")]),_._v(" "),e("p",[_._v("CSS 的 z-index 属性大家可能都知道，它代表了框的第三个维度，也就是沿“z 轴”方向的位置。")]),_._v(" "),e("p",[_._v("这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。")]),_._v(" "),e("p",[_._v("堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。")]),_._v(" "),e("h4",{attrs:{id:"动态变化的绘制策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态变化的绘制策略"}},[_._v("#")]),_._v(" 动态变化的绘制策略")]),_._v(" "),e("p",[_._v("在发生变化时，浏览器会尽可能做出最小的响应。")]),_._v(" "),e("p",[_._v("因此：")]),_._v(" "),e("ul",[e("li",[_._v("元素的颜色改变后，只会对该元素进行重绘。")]),_._v(" "),e("li",[_._v("元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。")]),_._v(" "),e("li",[_._v("添加 DOM 节点后，会对该节点进行布局和重绘。")])]),_._v(" "),e("p",[_._v("一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。")]),_._v(" "),e("p",[_._v("浏览器从下载文档到显示页面的过程是个复杂的过程，这里包含了重绘（repaints）和重排（reflows）。")]),_._v(" "),e("p",[_._v("各家浏览器引擎的工作原理略有差别，但也有一定规则。简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。")]),_._v(" "),e("p",[_._v("由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。")]),_._v(" "),e("p",[_._v("重绘是一个元素外观的改变所触发的浏览器行为，例如改变vidibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。")]),_._v(" "),e("p",[_._v("重排是更明显的一种改变，可以理解为渲染树需要重新计算。")]),_._v(" "),e("p",[_._v("开发中，比较好的实践是尽量减少重排次数和缩小重排的影响范围。例如：")]),_._v(" "),e("ol",[e("li",[_._v("将多次改变样式属性的操作合并成一次操作。")])]),_._v(" "),e("p",[_._v("可以合并为：")]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("p",[_._v("将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。")])]),_._v(" "),e("li",[e("p",[_._v("在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。")])]),_._v(" "),e("li",[e("p",[_._v("由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。")])]),_._v(" "),e("li",[e("p",[_._v("在需要经常取那些引起浏览器重排的属性值时，要缓存到变量。")])])]),_._v(" "),e("h4",{attrs:{id:"重排与重绘的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排与重绘的区别"}},[_._v("#")]),_._v(" 重排与重绘的区别")]),_._v(" "),e("p",[_._v("Reflow 和 Repaint 这两个不是一回事。")]),_._v(" "),e("ul",[e("li",[_._v("Repaint：屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。")]),_._v(" "),e("li",[_._v("Reflow：意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。")])]),_._v(" "),e("p",[_._v("HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow。reflow 会从")]),e("html",[_._v("这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。"),e("p"),_._v(" "),e("p",[_._v("Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。")]),_._v(" "),e("p",[_._v("所以，下面这些动作有很大可能会是成本比较高的。")]),_._v(" "),e("ul",[e("li",[_._v("当你增加、删除、修改DOM结点时，会导致Reflow或Repaint")]),_._v(" "),e("li",[_._v("当你移动DOM的位置，或是搞个动画的时候。")]),_._v(" "),e("li",[_._v("当你修改CSS样式的时候。")]),_._v(" "),e("li",[_._v("当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。")]),_._v(" "),e("li",[_._v("当你修改网页的默认字体时。")])]),_._v(" "),e("p",[_._v("注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。")]),_._v(" "),e("p",[_._v("多说两句关于滚屏的事，通常来说，如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。")]),_._v(" "),e("p",[_._v("基本上来说，reflow有如下的几个原因：")]),_._v(" "),e("ul",[e("li",[_._v("Initial。网页初始化的时候。")]),_._v(" "),e("li",[_._v("Incremental。一些Javascript在操作DOM Tree时。")]),_._v(" "),e("li",[_._v("Resize。其些元件的尺寸变了。")]),_._v(" "),e("li",[_._v("StyleChange。如果CSS的属性发生变化了。")]),_._v(" "),e("li",[_._v("Dirty。几个Incremental的reflow发生在同一个frame的子树上。")])]),_._v(" "),e("p",[_._v("我们来看一个示例：")]),_._v(" "),e("p",[_._v("当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。")]),_._v(" "),e("p",[_._v("但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：")]),_._v(" "),e("ol",[e("li",[_._v("offsetTop, offsetLeft, offsetWidth, offsetHeight")]),_._v(" "),e("li",[_._v("scrollTop/Left/Width/Height")]),_._v(" "),e("li",[_._v("clientTop/Left/Width/Height")]),_._v(" "),e("li",[_._v("IE中的 getComputedStyle(), 或 currentStyle")])]),_._v(" "),e("p",[_._v("因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。")]),_._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[_._v("#")]),_._v(" 参考")]),_._v(" "),e("p",[e("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110605",target:"_blank",rel:"noopener noreferrer"}},[_._v("呈现器的布局与layout过程"),e("OutboundLink")],1)]),_._v(" "),e("p",[e("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110609",target:"_blank",rel:"noopener noreferrer"}},[_._v("呈现器的Dirty位系统与各种布局介绍"),e("OutboundLink")],1)]),_._v(" "),e("p",[e("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110649",target:"_blank",rel:"noopener noreferrer"}},[_._v("呈现器的绘制方法与绘制顺序"),e("OutboundLink")],1)]),_._v(" "),e("p",[e("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110677",target:"_blank",rel:"noopener noreferrer"}},[_._v("关于Reflow和Repaint的更多细节"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);v.default=r.exports}}]);