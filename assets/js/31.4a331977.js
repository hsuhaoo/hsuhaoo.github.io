(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{510:function(v,_,t){"use strict";t.r(_);var r=t(4),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("我们都知道kill是Linux下常见的杀死进程的命令，并且kill -9 是强制杀死。那么，这个数字是什么意思？")]),v._v(" "),t("h2",{attrs:{id:"kill命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kill命令"}},[v._v("#")]),v._v(" kill命令")]),v._v(" "),t("p",[v._v("kill的命令参数有以下几种：")]),v._v(" "),t("p",[v._v("-l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称")]),v._v(" "),t("p",[v._v("-a 当处理当前进程时，不限制命令名和进程号的对应关系")]),v._v(" "),t("p",[v._v("-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号")]),v._v(" "),t("p",[v._v("-s 指定发送信号")]),v._v(" "),t("p",[v._v("-u 指定用户")]),v._v(" "),t("p",[v._v("信号如果没有指定的话，默认会发出终止信号(15)。常用的信号如下：")]),v._v(" "),t("blockquote",[t("p",[v._v("HUP 1 终端断线")]),v._v(" "),t("p",[v._v("INT 2 中断（同 Ctrl + C）")]),v._v(" "),t("p",[v._v("QUIT 3 退出（同 Ctrl + \\）")]),v._v(" "),t("p",[v._v("TERM 15 终止")]),v._v(" "),t("p",[v._v("KILL 9 强制终止")]),v._v(" "),t("p",[v._v("CONT 18 继续（与STOP相反， fg/bg命令）")]),v._v(" "),t("p",[v._v("STOP 19 暂停（同 Ctrl + Z）")])]),v._v(" "),t("h2",{attrs:{id:"linux中的信号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linux中的信号"}},[v._v("#")]),v._v(" Linux中的信号")]),v._v(" "),t("p",[v._v("那么，什么是信号？")]),v._v(" "),t("p",[v._v("在 Linux 系统（以及其他"),t("a",{attrs:{href:"http://c.biancheng.net/view/2621.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("类 Unix"),t("OutboundLink")],1),v._v(" 操作系统）中，信号被用于进程间的通信。信号是一个发送到某个进程或同一进程中的特定线程的异步通知，用于通知发生的一个事件。从 1970 年贝尔实验室的 Unix 面世便有了信号的概念，而现在它已经被定义在了 POSIX 标准中。")]),v._v(" "),t("p",[v._v("当一个事件发生时，会产生一个信号，然后内核会将事件传递到接收的进程。有时，进程可以发送一个信号到其他进程。除了进程到进程的信号外，还有很多种情况，内核会产生一个信号，比如文件大小达到限额、一个 I/O 设备就绪或用户发送了一个类似于 Ctrl+C 或 Ctrl+Z 的终端中断等。")]),v._v(" "),t("p",[v._v("运行在用户模式下的进程会接收信号。如果接收的进程正运行在内核模式（内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间），那么信号的执行只有在该进程返回到用户模式时才会开始。")]),v._v(" "),t("p",[v._v("发送到非运行进程的信号一定是由内核保存，直到进程重新执行为止。休眠的进程可以是可中断的，也可以是不可中断的。如果一个在可中断休眠状态的进程（例如，等待终端输入的进程）收到了一个信号，那么内核会唤醒这个进程来处理信号。如果一个在不可中断休眠状态的进程收到了一个信号，那么内核会拖延此信号，直到该事件完成为止。")]),v._v(" "),t("p",[v._v("当进程收到一个信号时，可能会发生以下 3 种情况：")]),v._v(" "),t("ul",[t("li",[v._v("进程可能会忽略此信号。有些信号不能被忽略，而有些没有默认行为的信号，默认会被忽略。有两种信号不能被忽略（分别是 "),t("code",[v._v("SIGKILL")]),v._v("和"),t("code",[v._v("SIGSTOP")]),v._v("）")]),v._v(" "),t("li",[v._v("进程可能会捕获此信号，并执行一个被称为信号处理器的特殊函数。")]),v._v(" "),t("li",[v._v("进程可能会执行信号的默认行为。例如，信号 15(SIGTERM) 的默认行为是结束进程。")])]),v._v(" "),t("p",[v._v("当一个进程执行信号处理时，如果还有其他信号到达，那么新的信号会被阻断直到处理器返冋为止。")]),v._v(" "),t("p",[v._v('为什么我们有的时候使用kill命令是没办法"杀死"应用？因为默认的kill信号是SIGTERM（15），程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。但是，如果在"准备工作"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。对于SIGKILL(9)，应用程序是没有时间进行"准备工作"的，且不能被忽略，'),t("strong",[v._v("所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。")])]),v._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.hollischuang.com/archives/4823",target:"_blank",rel:"noopener noreferrer"}},[v._v("我到服务器执行kill -9后，就被通知第二天别来了！"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"http://c.biancheng.net/view/3482.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Linux中的信号"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);