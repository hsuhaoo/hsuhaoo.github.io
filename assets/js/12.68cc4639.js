(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{495:function(t,a,r){"use strict";r.r(a);var e=r(4),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h4",{attrs:{id:"浏览器的组成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的组成"}},[t._v("#")]),t._v(" 浏览器的组成")]),t._v(" "),r("p",[t._v("想要知道"),r("a",{attrs:{href:"http://www.nowamagic.net/academy/tag/%E6%B5%8F%E8%A7%88%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器"),r("OutboundLink")],1),t._v("的工作原理以及浏览器的内核，我们要先知道浏览器的结构。")]),t._v(" "),r("p",[t._v("简单来说浏览器可以分为两部分，shell+内核。Shell是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。")]),t._v(" "),r("p",[t._v("浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和JS引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至 显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内 容的应用程序都需要内核。")]),t._v(" "),r("p",[t._v("JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、 Presto、Webkit。")]),t._v(" "),r("h4",{attrs:{id:"浏览器的结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的结构"}},[t._v("#")]),t._v(" 浏览器的结构")]),t._v(" "),r("p",[t._v("浏览器一般由以下"),r("a",{attrs:{href:"http://www.nowamagic.net/academy/tag/%E7%BB%84%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[t._v("组件"),r("OutboundLink")],1),t._v("构成 ：")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("用户界面")]),t._v("。包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。")]),t._v(" "),r("li",[r("strong",[t._v("浏览器引擎")]),t._v("。在用户界面和呈现引擎之间传送指令。")]),t._v(" "),r("li",[r("strong",[t._v("呈现引擎")]),t._v("。负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。")]),t._v(" "),r("li",[r("strong",[t._v("网络")]),t._v("。用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。")]),t._v(" "),r("li",[r("strong",[t._v("用户界面后端")]),t._v("。用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。")]),t._v(" "),r("li",[r("strong",[t._v("JavaScript 解释器")]),t._v("。用于解析和执行 JavaScript 代码。")]),t._v(" "),r("li",[r("strong",[t._v("数据存储")]),t._v("。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"http://www.nowamagic.net/librarys/images/201404/2014_04_04_02.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"呈现引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#呈现引擎"}},[t._v("#")]),t._v(" 呈现引擎")]),t._v(" "),r("p",[t._v("呈现引擎负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。")]),t._v(" "),r("p",[t._v("呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。")]),t._v(" "),r("p",[t._v("然后进行如下所示的基本流程：")]),t._v(" "),r("p",[r("img",{attrs:{src:"http://www.nowamagic.net/librarys/images/201404/2014_04_05_01.png",alt:"img"}})]),t._v(" "),r("p",[t._v("呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。（Geko里称为“框架树”。）")]),t._v(" "),r("p",[t._v("呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形，通常对应于相关节点的 CSS 框。它包含诸如宽度、高度和位置等几何信息。就是 CSS 里常提到的盒子模型。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。呈现器是和 DOM 元素相对应的，但并非一一对应。比如非可视化的 "),r("a",{attrs:{href:"http://www.nowamagic.net/academy/tag/DOM",target:"_blank",rel:"noopener noreferrer"}},[t._v("DOM"),r("OutboundLink")],1),t._v(" 元素不会插入呈现树中。有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。")]),t._v(" "),r("p",[t._v("呈现树构建完毕之后，进入“布局”处理阶段（Geko里称为“重排”），也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。")]),t._v(" "),r("p",[t._v("需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。")]),t._v(" "),r("h4",{attrs:{id:"浏览器渲染html的顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染html的顺序"}},[t._v("#")]),t._v(" 浏览器渲染html的顺序")]),t._v(" "),r("ol",[r("li",[t._v("渲染进程将HTML内容转换为能够读懂的DOM树结构。")]),t._v(" "),r("li",[t._v("渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。")]),t._v(" "),r("li",[t._v("创建布局树，并计算元素的布局信息。")]),t._v(" "),r("li",[t._v("对布局树进⾏分层，并⽣成分层树。")]),t._v(" "),r("li",[t._v("为每个图层⽣成绘制列表，并将其提交到合成线程。")]),t._v(" "),r("li",[t._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),t._v(" "),r("li",[t._v("合成线程发送绘制图块命令DrawQuad给浏览器进程。")]),t._v(" "),r("li",[t._v("浏览器进程根据DrawQuad消息⽣成⻚⾯，并显⽰到显⽰器上。")])]),t._v(" "),r("h4",{attrs:{id:"js的加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js的加载"}},[t._v("#")]),t._v(" JS的加载")]),t._v(" "),r("ul",[r("li",[t._v("不能并行下载和解析（阻塞下载）")]),t._v(" "),r("li",[t._v("正常情况下，当引用了JS的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用 document.write 或 appendChild，甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。")]),t._v(" "),r("li",[t._v("有 async，script.js会被异步加载，即加载和渲染后续文档元素的过程将和 script.js 的加载并行进行（异步）。当 script.js加载完整立即执行script.js。执行script.js时，html解析暂停。从加载完成立即执行来看，async模式 执行顺序与写的顺序无关，不保证执行顺序。")]),t._v(" "),r("li",[t._v("有 defer，script.js会被异步加载，即加载和渲染后续文档元素的过程将和 script.js 的加载并行进行（异步）。这一点与async模式一致。不同的是当 script.js加载完成并不会立即执行，而是在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。因此它会按照写的顺序执行。")])]),t._v(" "),r("h4",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110122",target:"_blank",rel:"noopener noreferrer"}},[t._v("现代浏览器的呈现引擎的工作流程介绍"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110160",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器加载和渲染HTML的顺序以及Gzip的问题"),r("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=_.exports}}]);