(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{508:function(e,t,r){"use strict";r.r(t);var o=r(4),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h4",{attrs:{id:"react生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期"}},[e._v("#")]),e._v(" React生命周期")]),e._v(" "),r("p",[e._v("每个组件都包含“生命周期方法”，可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法·")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/5287253-80e1623c694bcf36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp",alt:"img"}})]),e._v(" "),r("p",[e._v("React的生命周期从广义上分为三个阶段：挂载、渲染、卸载，每个阶段又可以细分为Render阶段、Pre-commit阶段、Commit阶段")]),e._v(" "),r("h4",{attrs:{id:"挂载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[e._v("#")]),e._v(" 挂载")]),e._v(" "),r("p",[e._v("当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#constructor",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("constructor()")])]),r("OutboundLink")],1),e._v("通常用于以下两种情况，通过给 "),r("code",[e._v("this.state")]),e._v(" 赋值对象来初始化内部 state（"),r("strong",[e._v("不要调用 "),r("code",[e._v("setState()")]),e._v(" 方法")]),e._v("），为事件处理函数绑定实例，注意避免将 props 的值复制给 state（更新 prop 中时，并不会影响 state）。要避免在构造函数中引入任何副作用，应将对应的操作放置在 "),r("code",[e._v("componentDidMount")]),e._v(" 中。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("static getDerivedStateFromProps()")]),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state",target:"_blank",rel:"noopener noreferrer"}},[e._v("罕见的用例"),r("OutboundLink")],1),e._v("，即 state 的值在任何时候都取决于 props。可能会导致代码冗余，并使组件难以维护。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#render",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("render()")])]),r("OutboundLink")],1),e._v("class 组件中唯一必须实现的方法，纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。如果 shouldComponentUpdate() 返回 false，则不会调用 render()。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidmount",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("componentDidMount()")])]),r("OutboundLink")],1),e._v(" 在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。此处"),r("strong",[e._v("调用 "),r("code",[e._v("setState()")])]),e._v("。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。")])]),e._v(" "),r("h4",{attrs:{id:"更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[e._v("#")]),e._v(" 更新")]),e._v(" "),r("p",[e._v("当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("static getDerivedStateFromProps()")]),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#shouldcomponentupdate",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("shouldComponentUpdate()")]),r("OutboundLink")],1),e._v(" 目前，如果 "),r("code",[e._v("shouldComponentUpdate()")]),e._v(" 返回 "),r("code",[e._v("false")]),e._v("，则不会调用 "),r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#unsafe_componentwillupdate",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("UNSAFE_componentWillUpdate()")]),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#render",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("render()")]),r("OutboundLink")],1),e._v(" 和 "),r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidupdate",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("componentDidUpdate()")]),r("OutboundLink")],1),e._v("，后续表现可能发生改变。首先应"),r("strong",[e._v("考虑使用内置的 "),r("a",{attrs:{href:"https://react.docschina.org/docs/react-api.html#reactpurecomponent",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("PureComponent")]),r("OutboundLink")],1),e._v(" 组件")]),e._v("，"),r("code",[e._v("PureComponent")]),e._v(" 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#render",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("render()")])]),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#getsnapshotbeforeupdate",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("getSnapshotBeforeUpdate()")]),r("OutboundLink")],1),e._v(" 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidupdate",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("componentDidUpdate()")])]),r("OutboundLink")],1),e._v("更新后会被立即调用。首次渲染不会执行此方法。当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。可以"),r("strong",[e._v("调用 "),r("code",[e._v("setState()")])]),e._v("，但请注意"),r("strong",[e._v("它必须被包裹在一个条件语句里")]),e._v("，否则可能造成死循环")])]),e._v(" "),r("p",[e._v("下述方法即将过时，在新代码中应该避免使用它们：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#unsafe_componentwillupdate",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("UNSAFE_componentWillUpdate()")]),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#unsafe_componentwillreceiveprops",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("UNSAFE_componentWillReceiveProps()")]),r("OutboundLink")],1)])]),e._v(" "),r("h4",{attrs:{id:"卸载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[e._v("#")]),e._v(" 卸载")]),e._v(" "),r("p",[e._v("当组件从 DOM 中移除时会调用如下方法：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentwillunmount",target:"_blank",rel:"noopener noreferrer"}},[r("strong",[r("code",[e._v("componentWillUnmount()")])]),r("OutboundLink")],1),e._v("在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 "),r("code",[e._v("componentDidMount()")]),e._v(" 中创建的订阅等。")])]),e._v(" "),r("h4",{attrs:{id:"错误处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[e._v("#")]),e._v(" 错误处理")]),e._v(" "),r("p",[e._v("当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("static getDerivedStateFromError()")]),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidcatch",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("componentDidCatch()")]),r("OutboundLink")],1)])]),e._v(" "),r("h4",{attrs:{id:"react16生命周期与fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16生命周期与fiber"}},[e._v("#")]),e._v(" React16生命周期与Fiber")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4171647-6e32ddbc9980cc3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp",alt:"img"}})]),e._v(" "),r("p",[e._v("React15及之前版本的生命周期与React16有较大差异，如图，React16之前并划分不Render阶段、Pre-commit阶段、Commit阶段。这是因为使用了新的协调引擎Fiber 。它的主要目的是使 Virtual DOM 可以进行增量式渲染。")]),e._v(" "),r("h4",{attrs:{id:"同步更新过程的局限"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步更新过程的局限"}},[e._v("#")]),e._v(" 同步更新过程的局限")]),e._v(" "),r("p",[e._v("在React16之前，更新过程是同步的，这可能会导致性能问题。")]),e._v(" "),r("p",[e._v("当React决定要加载或者更新组件树时，会做很多事，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那React就一鼓作气运行到底，中途绝不停歇。当组件树比较庞大的时候，就会出现卡顿（掉帧）的情况。")]),e._v(" "),r("h4",{attrs:{id:"react-fiber的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber的方式"}},[e._v("#")]),e._v(" React Fiber的方式")]),e._v(" "),r("p",[e._v("破解JavaScript中同步操作时间过长的方法其实很简单——分片。")]),e._v(" "),r("p",[e._v("把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。")]),e._v(" "),r("p",[e._v("React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。")]),e._v(" "),r("p",[e._v("维护每一个分片的数据结构，就是Fiber。")]),e._v(" "),r("h4",{attrs:{id:"为什么叫fiber呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么叫fiber呢"}},[e._v("#")]),e._v(" 为什么叫Fiber呢？")]),e._v(" "),r("p",[e._v("大家应该都清楚进程（Process）和线程（Thread）的概念，在计算机科学中还有一个概念叫做Fiber，英文含义就是“纤维”，意指比Thread更细的线，也就是比线程(Thread)控制得更精密的并发处理机制。")]),e._v(" "),r("p",[e._v("上面说的Fiber和React Fiber不是相同的概念，但是，我相信，React团队把这个功能命名为Fiber，含义也是更加紧密的处理机制，比Thread更细。")]),e._v(" "),r("h4",{attrs:{id:"react-fiber对现有代码的影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber对现有代码的影响"}},[e._v("#")]),e._v(" React Fiber对现有代码的影响")]),e._v(" "),r("p",[e._v("理想情况下，React Fiber应该完全不影响现有代码，但可惜并完全是这样，要吃这个包子还真要知道一点这个包子怎么做的，你如果不喜欢吃甜的就不要吃糖包子，对不对？")]),e._v(" "),r("p",[e._v("在React Fiber中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会"),r("strong",[e._v("完全作废，然后等待机会重头再来")]),e._v("。")]),e._v(" "),r("p",[e._v("因为一个更新过程可能被打断，所以React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase。")]),e._v(" "),r("p",[e._v("在第一阶段Reconciliation Phase，React Fiber会找出需要更新哪些DOM，这个阶段是可以被打断的；但是到了第二阶段Commit Phase，那就一鼓作气把DOM更新完，绝不会被打断。")]),e._v(" "),r("p",[e._v("componentWillMount和componentWillUpdate这两个函数往往包含副作用，所以当使用React Fiber的时候一定要重点看这两个函数的实现（尽可能不使用）。")]),e._v(" "),r("h3",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("React.Component – React (docschina.org)"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/26027085",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Fiber是什么 - 知乎 (zhihu.com)"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);