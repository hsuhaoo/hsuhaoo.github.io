(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{511:function(t,s,_){"use strict";_.r(s);var v=_(4),a=Object(v.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),_("ul",[_("li",[t._v("所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（"),_("code",[t._v("null")]),t._v("除外）")]),t._v(" "),_("li",[t._v("所有的引用类型（数组、对象、函数），都有一个"),_("code",[t._v("__proto__")]),t._v("属性，属性值是一个普通的对象")]),t._v(" "),_("li",[t._v("所有的函数，都有一个"),_("code",[t._v("prototype")]),t._v("属性，属性值也是一个普通的对象")]),t._v(" "),_("li",[t._v("所有的引用类型（数组、对象、函数），"),_("code",[t._v("__proto__")]),t._v("属性值指向它的构造函数的"),_("code",[t._v("prototype")]),t._v("属性值")]),t._v(" "),_("li",[t._v("当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的"),_("code",[t._v("__proto__")]),t._v("（即它的构造函数的"),_("code",[t._v("prototype")]),t._v("）中寻找")]),t._v(" "),_("li",[t._v("所有从原型或更高级原型中得到、执行的方法，其中的"),_("code",[t._v("this")]),t._v("在执行时，就指向了当前这个触发事件执行的对象。")])]),t._v(" "),_("h3",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" "),_("code",[t._v("this")])]),t._v(" "),_("div",{staticClass:"language-javascript line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    console"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" \n"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    a"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  \n    foo"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" foo \n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \nobj"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" c "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br"),_("span",{staticClass:"line-number"},[t._v("11")]),_("br")])]),_("ul",[_("li",[t._v("对于直接调用 "),_("code",[t._v("foo")]),t._v(" 来说，不管 "),_("code",[t._v("foo")]),t._v(" 函数被放在了什么地方，"),_("code",[t._v("this")]),t._v(" 一定是 "),_("code",[t._v("window")])]),t._v(" "),_("li",[t._v("对于 "),_("code",[t._v("obj.foo()")]),t._v(" 来说，谁调用了函数，谁就是 "),_("code",[t._v("this")]),t._v("，所以在这个场景下 "),_("code",[t._v("foo")]),t._v(" 函数中的 "),_("code",[t._v("this")]),t._v(" 就是 "),_("code",[t._v("obj")]),t._v(" 对象")]),t._v(" "),_("li",[t._v("对于 "),_("code",[t._v("new")]),t._v(" 的方式来说，"),_("code",[t._v("this")]),t._v(" 被永远绑定在了 "),_("code",[t._v("c")]),t._v(" 上面，不会被任何方式改变 "),_("code",[t._v("this")])]),t._v(" "),_("li",[t._v("箭头函数其实是没有 "),_("code",[t._v("this")]),t._v(" 的，箭头函数中的 "),_("code",[t._v("this")]),t._v(" 只取决包裹箭头函数的第一个普通函数的 "),_("code",[t._v("this")]),t._v("。")]),t._v(" "),_("li",[t._v("对于 "),_("code",[t._v("bind")]),t._v(" 这些改变上下文的 API ，"),_("code",[t._v("this")]),t._v(" 取决于第一个参数，如果第一个参数为空，那么就是 "),_("code",[t._v("window")]),t._v("，不管给函数 "),_("code",[t._v("bind")]),t._v(" 几次，"),_("code",[t._v("fn")]),t._v(" 中的 "),_("code",[t._v("this")]),t._v(" 永远由第一次 "),_("code",[t._v("bind")]),t._v(" 决定。")])]),t._v(" "),_("h3",{attrs:{id:"执行上下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),_("p",[t._v("在一段 JS 脚本（即一个"),_("code",[t._v("<script>")]),t._v("标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 "),_("strong",[t._v("全局执行上下文")]),t._v(" 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为"),_("code",[t._v("undefined")]),t._v("，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。")]),t._v(" "),_("p",[t._v("另外，一个函数在执行之前，也会创建一个 "),_("strong",[t._v("函数执行上下文")]),t._v(" 环境，跟 "),_("strong",[t._v("全局上下文")]),t._v(" 差不多，不过 "),_("strong",[t._v("函数执行上下文")]),t._v(" 中会多出"),_("code",[t._v("this")]),t._v(" "),_("code",[t._v("arguments")]),t._v("和函数的参数。")]),t._v(" "),_("p",[t._v("ES6新增了"),_("code",[t._v("let")]),t._v("命令，用来声明变量。它的用法类似于"),_("code",[t._v("var")]),t._v("，但是所声明的变量，只在"),_("code",[t._v("let")]),t._v("命令所在的"),_("strong",[t._v("代码块")]),t._v("内有效。")]),t._v(" "),_("p",[t._v("和var不同的还有，let命令不存在"),_("strong",[t._v("变量提升")]),t._v("，所以声明前调用变量，都会报错，这就涉及到一个概念——"),_("strong",[t._v("暂时性死区")]),t._v("。")]),t._v(" "),_("p",[t._v("暂时性死区：")]),t._v(" "),_("p",[t._v("当程序的控制流程在新的作用域(module, function或block作用域)进行实例化时，在此作用域中的用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，也就是对声明语句进行求值运算，所以是不能被访问的，访问就会抛出错误。所以在这运行流程一进入作用域创建变量，到变量开始可被访问之间的一段时间，就称之为TDZ( temporal dead zone，暂时死区)。")]),t._v(" "),_("p",[t._v("JavaScript引擎是利⽤栈来管理执⾏上下⽂的。在执⾏上下⽂创建好后，JavaScript引擎会将 执⾏上下⽂压⼊栈中，通常把这种⽤来管理执⾏上下⽂的栈称为"),_("strong",[t._v("执⾏上下⽂栈")]),t._v("，⼜称"),_("strong",[t._v("调⽤栈")]),t._v("。")]),t._v(" "),_("p",[t._v("**this的值是在执行的时候才能确认，定义的时候不能确认。**因为"),_("code",[t._v("this")]),t._v("是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。箭头函数没有⾃⼰的执⾏上下⽂，所以它 会继承调⽤函数中的this。")]),t._v(" "),_("h3",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),_("p",[t._v("作用域就是一个独立的地盘，让变量不会外泄、暴露出去。ES6 之前 JS 没有块级作用域，只有全局作用域和函数作用域。")]),t._v(" "),_("p",[t._v("全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。")]),t._v(" "),_("p",[t._v("要得到"),_("code",[t._v("a")]),t._v("变量，但是在当前的作用域中没有定义"),_("code",[t._v("a")]),t._v("。当前作用域没有定义的变量，这称为 "),_("strong",[t._v("自由变量")]),t._v(" 。自由变量如何得到 —— 向父级作用域寻找。")]),t._v(" "),_("p",[t._v("如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 "),_("strong",[t._v("作用域链")]),t._v(" 。")]),t._v(" "),_("p",[t._v("其实在每个执⾏上下⽂的变量环境中，都包含了⼀个外部引⽤，⽤来指向外部的执⾏上下⽂，我们把这个外部引⽤称为"),_("strong",[t._v("outer")]),t._v("。 当⼀段代码使⽤了⼀个变量时，JavaScript引擎⾸先会在“当前的执⾏上下⽂”中查找该变量， 如果在当前的变量环境中没有查找到，那么JavaScript引擎会继 续在outer所指向的执⾏上下⽂中查找。")]),t._v(" "),_("p",[t._v("词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的，所以词法作⽤域是静态的作⽤域，"),_("strong",[t._v("词法作⽤域是代码阶段就决定好的，和函 数是怎么调⽤的没有关系。")])]),t._v(" "),_("p",[t._v("根据词法作⽤域的规则，内部函数总是可以访问它们的外部函数的变量，当通过调⽤⼀个外部函数返回⼀个内部函数后，即使该外部函数已 经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为"),_("strong",[t._v("闭包")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"new"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[t._v("#")]),t._v(" new")]),t._v(" "),_("p",[t._v("在调用 "),_("code",[t._v("new")]),t._v(" 的过程中会发生以上四件事情：")]),t._v(" "),_("p",[t._v("1.创建一个空的简单 JavaScript 对象（即{}）；")]),t._v(" "),_("p",[t._v("2.链接该对象（即设置该对象的构造函数）到另一个对象 ；（ 通俗理解就是新对象隐式原型__proto__链接到构造函数显式原型prototype上。）")]),t._v(" "),_("p",[t._v("3.将步骤 1 新创建的对象作为 this 的上下文 ；（ 实际是执行了构造函数 并将构造函数this指向新对象 ）")]),t._v(" "),_("p",[t._v("4.如果该函数没有返回对象，则返回 this。（ 实际是返回一个空对象， new Object()就是返回一个空对象{} ）")]),t._v(" "),_("p",[t._v("对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 "),_("code",[t._v("new Object()")]),t._v(" 的方式创建对象需要通过作用域链一层层找到 "),_("code",[t._v("Object")]),t._v("，但是你使用字面量的方式就没这个问题。")]),t._v(" "),_("h3",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),_("p",[t._v("掘金小册 前端面试之道")]),t._v(" "),_("p",[t._v("极客时间 浏览器工作原理与实践")])])}),[],!1,null,null,null);s.default=a.exports}}]);