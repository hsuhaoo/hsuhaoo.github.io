(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{513:function(v,_,e){"use strict";e.r(_);var o=e(4),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"原始-primitive-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原始-primitive-类型"}},[v._v("#")]),v._v(" 原始（Primitive）类型")]),v._v(" "),e("p",[v._v("在 JS 中，存在着 7种原始值，分别是：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("boolean")])]),v._v(" "),e("li",[e("code",[v._v("null")])]),v._v(" "),e("li",[e("code",[v._v("undefined")])]),v._v(" "),e("li",[e("code",[v._v("number")])]),v._v(" "),e("li",[e("code",[v._v("string")])]),v._v(" "),e("li",[e("code",[v._v("symbol")])]),v._v(" "),e("li",[e("code",[v._v("bigint")]),v._v("(es2020)")])]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("null")]),v._v(" 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 "),e("code",[v._v("typeof null")]),v._v(" 会输出 "),e("code",[v._v("object")]),v._v("，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，"),e("code",[v._v("000")]),v._v(" 开头代表是对象，然而 "),e("code",[v._v("null")]),v._v(" 表示为全零，所以将它错误的判断为 "),e("code",[v._v("object")]),v._v(" 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。")]),v._v(" "),e("h2",{attrs:{id:"对象-object-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象-object-类型"}},[v._v("#")]),v._v(" 对象（Object）类型")]),v._v(" "),e("p",[v._v("除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。")]),v._v(" "),e("p",[e("code",[v._v("typeof")]),v._v(" 对于原始类型来说，除了 "),e("code",[v._v("null")]),v._v(" 都可以显示正确的类型")]),v._v(" "),e("p",[e("code",[v._v("typeof")]),v._v(" 对于对象来说，除了函数都会显示 "),e("code",[v._v("object")]),v._v("，所以说 "),e("code",[v._v("typeof")]),v._v(" 并不能准确判断变量到底是什么类型")]),v._v(" "),e("p",[v._v("如果我们想判断一个对象的正确类型，这时候可以考虑使用 "),e("code",[v._v("instanceof")]),v._v("，因为内部机制是通过原型链来判断的")]),v._v(" "),e("p",[v._v("原始类型的数据值都是直接保存在“栈”中的，引⽤类型的值是存放在“堆”中 的（闭包把内部函数引⽤的外部变量保存到堆中）。JavaScript引擎需要⽤栈来维护程序执⾏期间上下⽂的状态，如果栈空间⼤了话，所有的数据都存放在栈空间⾥⾯，那么会影响到上下⽂切换的效率，进⽽⼜影响到整个程序的执⾏效率。")]),v._v(" "),e("h2",{attrs:{id:"类型转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[v._v("#")]),v._v(" 类型转换")]),v._v(" "),e("p",[v._v("在 JS 中类型转换只有三种情况，分别是：")]),v._v(" "),e("ul",[e("li",[v._v("转换为布尔值")]),v._v(" "),e("li",[v._v("转换为数字")]),v._v(" "),e("li",[v._v("转换为字符串")])]),v._v(" "),e("h3",{attrs:{id:"转boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转boolean"}},[v._v("#")]),v._v(" 转Boolean")]),v._v(" "),e("p",[v._v("在条件判断时，除了 "),e("code",[v._v("undefined")]),v._v("， "),e("code",[v._v("null")]),v._v("， "),e("code",[v._v("false")]),v._v("， "),e("code",[v._v("NaN")]),v._v("， "),e("code",[v._v("''")]),v._v("， "),e("code",[v._v("0")]),v._v("， "),e("code",[v._v("-0")]),v._v("，其他所有值都转为 "),e("code",[v._v("true")]),v._v("，包括所有对象。")]),v._v(" "),e("h3",{attrs:{id:"对象转原始类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型"}},[v._v("#")]),v._v(" 对象转原始类型")]),v._v(" "),e("p",[v._v("对象在转换类型的时候，会调用内置的 "),e("code",[v._v("[[ToPrimitive]]")]),v._v(" 函数，对于该函数来说，算法逻辑一般来说如下：")]),v._v(" "),e("ul",[e("li",[v._v("如果已经是原始类型了，那就不需要转换了")]),v._v(" "),e("li",[v._v("调用 "),e("code",[v._v("x.valueOf()")]),v._v("，如果转换为基础类型，就返回转换的值")]),v._v(" "),e("li",[v._v("调用 "),e("code",[v._v("x.toString()")]),v._v("，如果转换为基础类型，就返回转换的值")]),v._v(" "),e("li",[v._v("如果都没有返回原始类型，就会报错")])]),v._v(" "),e("h3",{attrs:{id:"四则运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四则运算符"}},[v._v("#")]),v._v(" 四则运算符")]),v._v(" "),e("p",[v._v("加法运算符不同于其他几个运算符，它有以下几个特点：")]),v._v(" "),e("ul",[e("li",[v._v("运算中其中一方为字符串，那么就会把另一方也转换为字符串")]),v._v(" "),e("li",[v._v("如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")])]),v._v(" "),e("p",[v._v("对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字")]),v._v(" "),e("h3",{attrs:{id:"比较运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[v._v("#")]),v._v(" 比较运算符")]),v._v(" "),e("ol",[e("li",[v._v("如果是对象，就通过 "),e("code",[v._v("toPrimitive")]),v._v(" 转换对象")]),v._v(" "),e("li",[v._v("如果是字符串，就通过 "),e("code",[v._v("unicode")]),v._v(" 字符索引来比较")])]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("==")]),v._v(" 来说，如果对比双方的类型"),e("strong",[v._v("不一样")]),v._v("的话，就会进行"),e("strong",[v._v("类型转换")])]),v._v(" "),e("p",[v._v("假如我们需要对比 "),e("code",[v._v("x")]),v._v(" 和 "),e("code",[v._v("y")]),v._v(" 是否相同，就会进行如下判断流程：")]),v._v(" "),e("ol",[e("li",[v._v("首先会判断两者类型是否"),e("strong",[v._v("相同")]),v._v("。相同的话就是比大小了")]),v._v(" "),e("li",[v._v("类型不相同的话，那么就会进行类型转换")]),v._v(" "),e("li",[v._v("会先判断是否在对比 "),e("code",[v._v("null")]),v._v(" 和 "),e("code",[v._v("undefined")]),v._v("，是的话就会返回 "),e("code",[v._v("true")])]),v._v(" "),e("li",[v._v("判断两者类型是否为 "),e("code",[v._v("string")]),v._v(" 和 "),e("code",[v._v("number")]),v._v("，是的话就会将字符串转换为 "),e("code",[v._v("number")])]),v._v(" "),e("li",[v._v("判断其中一方是否为 "),e("code",[v._v("boolean")]),v._v("，是的话就会把 "),e("code",[v._v("boolean")]),v._v(" 转为 "),e("code",[v._v("number")]),v._v(" 再进行判断")]),v._v(" "),e("li",[v._v("判断其中一方是否为 "),e("code",[v._v("object")]),v._v(" 且另一方为 "),e("code",[v._v("string")]),v._v("、"),e("code",[v._v("number")]),v._v(" 或者 "),e("code",[v._v("symbol")]),v._v("，是的话就会把 "),e("code",[v._v("object")]),v._v(" 转为原始类型再进行判断")])]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("===")]),v._v(" 来说就简单多了，就是判断两者类型和值是否相同。")]),v._v(" "),e("p",[v._v("为什么 0.1 + 0.2 != 0.3？")]),v._v(" "),e("p",[v._v("因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。")]),v._v(" "),e("p",[v._v("计算机是通过二进制来存储东西的，那么 "),e("code",[v._v("0.1")]),v._v(" 在二进制中会表示为")]),v._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("0.1 = 2^-4 * 1.10011(0011)\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("p",[v._v("我们可以发现，"),e("code",[v._v("0.1")]),v._v(" 在二进制中是无限循环的一些数字，其实不只是 "),e("code",[v._v("0.1")]),v._v("，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 "),e("code",[v._v("0.1")]),v._v(" 不再是 "),e("code",[v._v("0.1")]),v._v(" 了，而是变成了 "),e("code",[v._v("0.100000000000000002")])]),v._v(" "),e("h3",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),e("p",[v._v("掘金小册 前端面试之道")])])}),[],!1,null,null,null);_.default=t.exports}}]);