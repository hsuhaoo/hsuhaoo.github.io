(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{503:function(v,t,T){"use strict";T.r(t);var e=T(4),_=Object(e.a)({},(function(){var v=this,t=v.$createElement,T=v._self._c||t;return T("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[T("p",[v._v("HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作发布了一系列相关的RFC，其中最著名的就是RFC 2616，定义了今天普遍使用的一个版本——HTTP 1.1。")]),v._v(" "),T("p",[v._v("HTTP协议位于计算机网络中的应用层，通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。默认HTTP的端口号为80，HTTPS的端口号为443。")]),v._v(" "),T("p",[v._v("HTTP是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。客户端和服务端通过交换各自的消息进行交互。由像浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫做 responses。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系，但使用Cookies可以创建有状态的会话。")]),v._v(" "),T("h3",{attrs:{id:"http工作过程"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#http工作过程"}},[v._v("#")]),v._v(" HTTP工作过程")]),v._v(" "),T("p",[v._v("一次HTTP操作称为一个事务，其工作过程可分为四步：")]),v._v(" "),T("p",[v._v("1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。")]),v._v(" "),T("p",[v._v("2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。")]),v._v(" "),T("p",[v._v("3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。")]),v._v(" "),T("p",[v._v("4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。")]),v._v(" "),T("p",[v._v("HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。最常用的两个传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。")]),v._v(" "),T("p",[v._v("在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。")]),v._v(" "),T("p",[v._v("为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。")]),v._v(" "),T("p",[T("strong",[v._v("HTTP 流")]),v._v("\n当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步：\n打开一个TCP连接：TCP连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。\n发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。\n关闭连接或者为后续请求重用连接。\n当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。")]),v._v(" "),T("p",[T("strong",[v._v("基于HTTP的APIs")]),v._v("\n基于HTTP的最常用API是XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。\nEventSourceAPI，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。")]),v._v(" "),T("h3",{attrs:{id:"http方法"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#http方法"}},[v._v("#")]),v._v(" HTTP方法")]),v._v(" "),T("p",[v._v("HTTP的1.0版本中只有三种请求方法： GET, POST 和 HEAD方法。到了1.1版本时，新增加了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。")]),v._v(" "),T("p",[T("strong",[v._v("GET和POST的区别：")])]),v._v(" "),T("ol",[T("li",[v._v("GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的：\nlogin.action?name=hyddd&password=idontknow&verify=%E4%BD%E5%A5%BD\n其中，以?来分隔URL和数据；以&来分隔参数；如果数据是英文或数字，原样发送；如果数据是中文或其它字符，则进行BASE64编码。\n而Post是把提交的数据放在HTTP正文中的。")]),v._v(" "),T("li",[v._v("GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到浏览器等不同环境的限制的，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制）。")]),v._v(" "),T("li",[v._v("Post的安全性要比Get高，因为Get时，参数数据是明文传输的，参数直接暴露在url中，所以不能用来传递敏感信息。")]),v._v(" "),T("li",[v._v("get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。")]),v._v(" "),T("li",[v._v("GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。\n通常，开发者将每个HTTP方法与CRUD操作一一对应。")])]),v._v(" "),T("p",[v._v("CRUD       HTTP\nCreate      POST\nRead         GET\nUpdate     PUT\nDelete      DELETE")]),v._v(" "),T("p",[v._v('的确是这样，而且GET与DELETE对应的操作是很明确的，但论及与create和update对应的HTTP方法时要取决于幂等性。幂等性在HTTP规范中是一个很重要的概念。它规定对于执行多次相同的HTTP请求，处于服务端的资源的状态是相同的。GET，HEAD， PUT与DELETE都具有这种特性，但POST没有。\n为便于说明状态统一性，我们会使用一个Account集合("/accounts")，并且为了简洁我们假设每个account资源都有三个属性：givenName, surname，和status。\n假设你使用HTTP PUT方法提交了一个update请求。在请求体中，你设置了givenName和surname的值分别为"John"和"Smith"。接着你又提交了另一个HTTP PUT的请求，这次你将givenName的值设置为"Johnny"。它是幂等的么？不。为什么呢？因为在这两次请求的间隙，其他请求可能已经改变了account资源的服务端状态。例如，在这两次请求之间，status的值可能已经变成了“blocked"。我们示范的请求在重复提交时不能保证在服务端的account资源的状态是相同的。\nPUT 意为提交一个资源——用一个不同的事物完全替代给定的URL下的所有可访问资源。要使用PUT请求，你必须发送所有可访问属性/值，而不仅仅是你想要改变的那些。 如果我们在发送givenName和surname时加上状态值“disabled"，则本次调用是幂等的并且消除了副作用。幂等性是HTTP规范的一项基本属性，并且必须确保web的互操作性与规模。\nPOST是目前惟一的状态不统一的方法。HTTP规范对它的定义也很宽泛，并且大体上将它定义为了一个“服务端处理指令”。这就意味着在POST请求中做任何处理都是“安全”的。')]),v._v(" "),T("h3",{attrs:{id:"连接"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[v._v("#")]),v._v(" 连接")]),v._v(" "),T("p",[v._v("HTTP 的连接管理适用于两个连续节点之间的连接，如 hop-by-hop，而不是 end-to-end。")]),v._v(" "),T("p",[T("strong",[v._v("短连接")])]),v._v(" "),T("p",[v._v("HTTP 最早期的模型，也是 HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手。")]),v._v(" "),T("p",[v._v("TCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的冷连接降低了其性能。")]),v._v(" "),T("p",[v._v("这是 HTTP/1.0 的默认模型。而在 HTTP/1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型。")]),v._v(" "),T("p",[v._v("除非是要兼容一个非常古老的，不支持长连接的系统，没有一个令人信服的理由继续使用这个模型。")]),v._v(" "),T("p",[T("strong",[v._v("长连接")])]),v._v(" "),T("p",[v._v("短连接有两个比较大的问题：创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后(热连接)才能得到改善。为了缓解这些问题，长连接 的概念便被设计出来了，甚至在 HTTP/1.1 之前。")]),v._v(" "),T("p",[v._v("一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。")]),v._v(" "),T("p",[v._v("长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。")]),v._v(" "),T("p",[v._v("在 HTTP/1.1 里，默认就是长连接的")]),v._v(" "),T("h3",{attrs:{id:"http-2-及-http-3"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#http-2-及-http-3"}},[v._v("#")]),v._v(" HTTP/2 及 HTTP/3")]),v._v(" "),T("p",[T("strong",[v._v("HTTP/2")])]),v._v(" "),T("p",[v._v("HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。")]),v._v(" "),T("p",[v._v("在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。")]),v._v(" "),T("p",[v._v("在 HTTP/2 中引入了多路复用的技术，就是在一个 TCP 连接中可以存在多条流，只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。")]),v._v(" "),T("p",[v._v("在之前的 HTTP 版本中，通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。")]),v._v(" "),T("p",[v._v("在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。")]),v._v(" "),T("p",[v._v("在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。")]),v._v(" "),T("p",[T("strong",[v._v("HTTP/3")])]),v._v(" "),T("p",[v._v("虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。")]),v._v(" "),T("p",[v._v("因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。")]),v._v(" "),T("p",[v._v("那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。")]),v._v(" "),T("p",[v._v("基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。")]),v._v(" "),T("p",[T("strong",[v._v("QUIC")])]),v._v(" "),T("p",[v._v("UDP 协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、纠错机制、重传等等功能。")]),v._v(" "),T("p",[v._v("虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。")]),v._v(" "),T("p",[v._v("并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。")]),v._v(" "),T("h3",{attrs:{id:"常见状态码"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[v._v("#")]),v._v(" 常见状态码")]),v._v(" "),T("p",[v._v("状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求是成功还是失败，如果失败的话，是什么原因导致的，当然状态码也是用于传达语义的。")]),v._v(" "),T("p",[v._v("HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。")]),v._v(" "),T("p",[v._v("HTTP状态码共分为5种类型：")]),v._v(" "),T("p",[v._v("1**    信息，服务器收到请求，需要请求者继续执行操作")]),v._v(" "),T("p",[v._v("2**    成功，操作被成功接收并处理")]),v._v(" "),T("p",[v._v("3**    重定向，需要进一步的操作以完成请求")]),v._v(" "),T("p",[v._v("4**    客户端错误，请求包含语法错误或无法完成请求")]),v._v(" "),T("p",[v._v("5**    服务器错误，服务器在处理请求的过程中发生了错误")]),v._v(" "),T("p",[T("strong",[v._v("2XX 成功")])]),v._v(" "),T("ul",[T("li",[v._v("200 OK，表示从客户端发来的请求在服务器端被正确处理")]),v._v(" "),T("li",[v._v("204 No content，表示请求成功，但响应报文不含实体的主体部分")]),v._v(" "),T("li",[v._v("205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容")]),v._v(" "),T("li",[v._v("206 Partial Content，进行范围请求")])]),v._v(" "),T("p",[T("strong",[v._v("3XX 重定向")])]),v._v(" "),T("ul",[T("li",[v._v("301 moved permanently，永久性重定向，表示资源已被分配了新的 URL")]),v._v(" "),T("li",[v._v("302 found，临时性重定向，表示资源临时被分配了新的 URL")]),v._v(" "),T("li",[v._v("303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源")]),v._v(" "),T("li",[v._v("304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况")]),v._v(" "),T("li",[v._v("307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求")])]),v._v(" "),T("p",[T("strong",[v._v("4XX 客户端错误")])]),v._v(" "),T("ul",[T("li",[v._v("400 bad request，请求报文存在语法错误")]),v._v(" "),T("li",[v._v("401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息")]),v._v(" "),T("li",[v._v("403 forbidden，表示对请求资源的访问被服务器拒绝")]),v._v(" "),T("li",[v._v("404 not found，表示在服务器上没有找到请求的资源")])]),v._v(" "),T("p",[T("strong",[v._v("5XX 服务器错误")])]),v._v(" "),T("ul",[T("li",[v._v("500 internal sever error，表示服务器端在执行请求时发生了错误")]),v._v(" "),T("li",[v._v("501 Not Implemented，表示服务器不支持当前请求所需要的某个功能")]),v._v(" "),T("li",[v._v("503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求")])]),v._v(" "),T("h3",{attrs:{id:"ssl-tls"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls"}},[v._v("#")]),v._v(" SSL/TLS")]),v._v(" "),T("p",[v._v("SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。")]),v._v(" "),T("p",[v._v("在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。")]),v._v(" "),T("p",[T("strong",[v._v("对称加密")]),v._v("：")]),v._v(" "),T("p",[v._v("对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。")]),v._v(" "),T("p",[T("strong",[v._v("非对称加密")]),v._v("：")]),v._v(" "),T("p",[v._v("有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。")]),v._v(" "),T("p",[v._v("这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。")]),v._v(" "),T("p",[v._v("简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。")]),v._v(" "),T("p",[T("strong",[v._v("TLS 握手过程如下：")])]),v._v(" "),T("p",[T("img",{attrs:{src:"https://segmentfault.com/img/bVbCCMD",alt:"SSL : TLS 握手过程"}})]),v._v(" "),T("ol",[T("li",[v._v('**"client hello"消息：**客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。')]),v._v(" "),T("li",[v._v('**"server hello"消息：**服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。')]),v._v(" "),T("li",[v._v("**验证：**客户端对服务器发来的证书进行验证，确保对方的合法身份")]),v._v(" "),T("li",[v._v('**"premaster secret"字符串：**客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。')]),v._v(" "),T("li",[v._v('**使用私钥：**服务器使用私钥解密"premaster secret"。')]),v._v(" "),T("li",[T("strong",[v._v("生成共享密钥")]),v._v("：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 "),T("strong",[v._v("KEY")]),v._v("。")]),v._v(" "),T("li",[v._v("**客户端就绪：**客户端发送经过共享密钥 "),T("strong",[v._v("KEY")]),v._v('加密过的"finished"信号。')]),v._v(" "),T("li",[v._v("**服务器就绪：**服务器发送经过共享密钥 "),T("strong",[v._v("KEY")]),v._v('加密过的"finished"信号。')]),v._v(" "),T("li",[v._v("**达成安全通信：**握手完成，双方使用对称加密进行安全通信。")])]),v._v(" "),T("h3",{attrs:{id:"参考"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),T("p",[T("a",{attrs:{href:"http://www.blogjava.net/zjusuyong/articles/304788.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("深入学习HTTP协议"),T("OutboundLink")],1)]),v._v(" "),T("p",[T("a",{attrs:{href:"https://blog.csdn.net/vikeyyyy/article/details/80655115",target:"_blank",rel:"noopener noreferrer"}},[v._v("HTTP协议——HTTP方法"),T("OutboundLink")],1)]),v._v(" "),T("p",[T("a",{attrs:{href:"https://www.oschina.net/translate/put-or-post",target:"_blank",rel:"noopener noreferrer"}},[v._v("PUT 还是 POST ? "),T("OutboundLink")],1)]),v._v(" "),T("p",[T("a",{attrs:{href:"https://www.runoob.com/http/http-status-codes.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("HTTP状态码"),T("OutboundLink")],1)]),v._v(" "),T("p",[T("a",{attrs:{href:"https://www.techug.com/post/https-ssl-tls.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("聊聊HTTPS和SSL/TLS协议"),T("OutboundLink")],1)]),v._v(" "),T("p",[T("a",{attrs:{href:"https://segmentfault.com/a/1190000021559557",target:"_blank",rel:"noopener noreferrer"}},[v._v("HTTPS详解二：SSL / TLS 工作原理和详细握手过程"),T("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);