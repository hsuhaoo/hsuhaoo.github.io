(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{502:function(t,r,e){"use strict";e.r(r);var a=e(4),n=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("页面的性能对于用户的体验十分重要，因此监控页面的某些指标，从而改善页面性能，是一个重要的话题。")]),t._v(" "),e("p",[t._v("前端性能监控主要分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。")]),t._v(" "),e("h3",{attrs:{id:"合成监控-syn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成监控-syn"}},[t._v("#")]),t._v(" 合成监控（SYN）")]),t._v(" "),e("p",[t._v("合成监控就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。合成监控中比较流行的是 Google 的 Lighthouse。")]),t._v(" "),e("h5",{attrs:{id:"合成监控的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成监控的优缺点"}},[t._v("#")]),t._v(" 合成监控的优缺点")]),t._v(" "),e("p",[t._v("优点：方案成熟、能采集到更丰富的数据、不影响真实用户体验、可在上线前进行")]),t._v(" "),e("p",[t._v("缺点：数据不稳定、数据量较小、登录态等需要做额外处理")]),t._v(" "),e("h3",{attrs:{id:"真实用户监控-rum"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#真实用户监控-rum"}},[t._v("#")]),t._v(" 真实用户监控（RUM）")]),t._v(" "),e("p",[t._v("真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标，我们在用户访问结束的时候，把这些性能指标上传到我们的日志服务器上，进行数据的提取清洗加工。最基础的方式是基于performance.timing API实现")]),t._v(" "),e("h5",{attrs:{id:"真实用户监控-rum-的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#真实用户监控-rum-的优缺点"}},[t._v("#")]),t._v(" 真实用户监控(RUM)的优缺点")]),t._v(" "),e("p",[t._v("优点：无需配置模拟条件、数据样本足够大")]),t._v(" "),e("p",[t._v("缺点：一定程度上影响用户、访问量较小的页面结果可能存在一定偏差")]),t._v(" "),e("h3",{attrs:{id:"常见的性能监控指标有"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的性能监控指标有"}},[t._v("#")]),t._v(" 常见的性能监控指标有")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("白屏时间")]),t._v("：用户从打开页面开始到页面开始有东西呈现为止，这过程中占用的时间就是白屏时间")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("首屏时间")]),t._v("：用户浏览器首屏内所有内容都呈现出来所花费的时间")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("用户可操作时间")]),t._v("：用户可以进行正常的点击、输入等操作")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("页面总下载时间")]),t._v("：页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("自定义的时间点")]),t._v("：对于开发人员来说，完全可以自定义一些时间点，例如：某个组件 init 完成的时间、某个重要模块加载的时间等等")])])]),t._v(" "),e("h3",{attrs:{id:"chrome-performance中定义的指标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome-performance中定义的指标"}},[t._v("#")]),t._v(" Chrome Performance中定义的指标")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("FP (First Paint) 首次绘制:")]),t._v(" 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点.")]),t._v(" "),e("li",[e("strong",[t._v("FCP (First Contentful Paint)")]),t._v(" 首次内容绘制 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素. 网站在"),e("em",[t._v("iframe 中")]),t._v("包含的任何内容都不会被FCP考虑在内。也不是非内容绘画，例如背景颜色的变化.")]),t._v(" "),e("li",[e("strong",[t._v("LCP (Largest Contentful Paint) 最大内容渲染:")]),t._v(" 代表在viewport中最大的页面元素加载的时间. LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象.(2019年11月新增)")]),t._v(" "),e("li",[e("strong",[t._v("DCL (DomContentloaded):")]),t._v(" 当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的完成加载.")]),t._v(" "),e("li",[e("strong",[t._v("FMP(First Meaningful Paint) 首次有效绘制:")]),t._v(" 例如，在 YouTube 观看页面上，主视频就是主角元素. 看这个csdn的网站不是很明显, 这几个都成一个时间线了, 截个weibo的看下. 下面的示例图可以看到, 微博的博文是主要元素.")]),t._v(" "),e("li",[e("strong",[t._v("L (onLoad),")]),t._v(" 当依赖的资源, 全部加载完毕之后才会触发.")])]),t._v(" "),e("h3",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://fex.baidu.com/blog/2014/05/front_end-data/",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端数据之美 -- 基础篇 - FEX (baidu.com)"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.infoq.cn/article/Dxa8aM44oz*Lukk5Ufhy",target:"_blank",rel:"noopener noreferrer"}},[t._v("蚂蚁金服如何把前端性能监控做到极致?-InfoQ"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/c_kite/article/details/104237256",target:"_blank",rel:"noopener noreferrer"}},[t._v("Chrome Performance常见名词解释(FP, FCP, LCP, DCL, FMP, TTI, TBT, FID, CLS)_翾的博客-CSDN博客"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=n.exports}}]);